/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const LTC_H: u32 = 1;
pub const LIBLTC_VERSION: &'static [u8; 6usize] = b"1.3.1\0";
pub const LIBLTC_VERSION_MAJOR: u32 = 1;
pub const LIBLTC_VERSION_MINOR: u32 = 3;
pub const LIBLTC_VERSION_MICRO: u32 = 1;
pub const LIBLTC_CUR: u32 = 12;
pub const LIBLTC_REV: u32 = 0;
pub const LIBLTC_AGE: u32 = 1;
pub const LTC_FRAME_BIT_COUNT: u32 = 80;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " default audio sample type: 8bit unsigned (mono)"]
pub type ltcsnd_sample_t = ::std::os::raw::c_uchar;
#[doc = " sample-count offset - 64bit wide"]
pub type ltc_off_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct LTCFrame {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 10usize], u16>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_LTCFrame() {
    assert_eq!(
        ::std::mem::size_of::<LTCFrame>(),
        12usize,
        concat!("Size of: ", stringify!(LTCFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<LTCFrame>(),
        4usize,
        concat!("Alignment of ", stringify!(LTCFrame))
    );
}
impl LTCFrame {
    #[inline]
    pub fn frame_units(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_frame_units(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn user1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_user1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_tens(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_tens(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dfbit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dfbit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn col_frame(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_col_frame(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_user2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secs_units(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_secs_units(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn user3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_user3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secs_tens(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_secs_tens(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn biphase_mark_phase_correction(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_biphase_mark_phase_correction(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user4(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_user4(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mins_units(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mins_units(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn user5(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_user5(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mins_tens(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mins_tens(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn binary_group_flag_bit0(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_binary_group_flag_bit0(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user6(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_user6(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn hours_units(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_hours_units(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn user7(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_user7(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn hours_tens(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hours_tens(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn binary_group_flag_bit1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_binary_group_flag_bit1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn binary_group_flag_bit2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_binary_group_flag_bit2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user8(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_user8(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sync_word(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sync_word(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_units: ::std::os::raw::c_uint,
        user1: ::std::os::raw::c_uint,
        frame_tens: ::std::os::raw::c_uint,
        dfbit: ::std::os::raw::c_uint,
        col_frame: ::std::os::raw::c_uint,
        user2: ::std::os::raw::c_uint,
        secs_units: ::std::os::raw::c_uint,
        user3: ::std::os::raw::c_uint,
        secs_tens: ::std::os::raw::c_uint,
        biphase_mark_phase_correction: ::std::os::raw::c_uint,
        user4: ::std::os::raw::c_uint,
        mins_units: ::std::os::raw::c_uint,
        user5: ::std::os::raw::c_uint,
        mins_tens: ::std::os::raw::c_uint,
        binary_group_flag_bit0: ::std::os::raw::c_uint,
        user6: ::std::os::raw::c_uint,
        hours_units: ::std::os::raw::c_uint,
        user7: ::std::os::raw::c_uint,
        hours_tens: ::std::os::raw::c_uint,
        binary_group_flag_bit1: ::std::os::raw::c_uint,
        binary_group_flag_bit2: ::std::os::raw::c_uint,
        user8: ::std::os::raw::c_uint,
        sync_word: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 10usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 10usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let frame_units: u32 = unsafe { ::std::mem::transmute(frame_units) };
            frame_units as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let user1: u32 = unsafe { ::std::mem::transmute(user1) };
            user1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let frame_tens: u32 = unsafe { ::std::mem::transmute(frame_tens) };
            frame_tens as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dfbit: u32 = unsafe { ::std::mem::transmute(dfbit) };
            dfbit as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let col_frame: u32 = unsafe { ::std::mem::transmute(col_frame) };
            col_frame as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let user2: u32 = unsafe { ::std::mem::transmute(user2) };
            user2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let secs_units: u32 = unsafe { ::std::mem::transmute(secs_units) };
            secs_units as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let user3: u32 = unsafe { ::std::mem::transmute(user3) };
            user3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let secs_tens: u32 = unsafe { ::std::mem::transmute(secs_tens) };
            secs_tens as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let biphase_mark_phase_correction: u32 =
                unsafe { ::std::mem::transmute(biphase_mark_phase_correction) };
            biphase_mark_phase_correction as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let user4: u32 = unsafe { ::std::mem::transmute(user4) };
            user4 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let mins_units: u32 = unsafe { ::std::mem::transmute(mins_units) };
            mins_units as u64
        });
        __bindgen_bitfield_unit.set(36usize, 4u8, {
            let user5: u32 = unsafe { ::std::mem::transmute(user5) };
            user5 as u64
        });
        __bindgen_bitfield_unit.set(40usize, 3u8, {
            let mins_tens: u32 = unsafe { ::std::mem::transmute(mins_tens) };
            mins_tens as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let binary_group_flag_bit0: u32 =
                unsafe { ::std::mem::transmute(binary_group_flag_bit0) };
            binary_group_flag_bit0 as u64
        });
        __bindgen_bitfield_unit.set(44usize, 4u8, {
            let user6: u32 = unsafe { ::std::mem::transmute(user6) };
            user6 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let hours_units: u32 = unsafe { ::std::mem::transmute(hours_units) };
            hours_units as u64
        });
        __bindgen_bitfield_unit.set(52usize, 4u8, {
            let user7: u32 = unsafe { ::std::mem::transmute(user7) };
            user7 as u64
        });
        __bindgen_bitfield_unit.set(56usize, 2u8, {
            let hours_tens: u32 = unsafe { ::std::mem::transmute(hours_tens) };
            hours_tens as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let binary_group_flag_bit1: u32 =
                unsafe { ::std::mem::transmute(binary_group_flag_bit1) };
            binary_group_flag_bit1 as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let binary_group_flag_bit2: u32 =
                unsafe { ::std::mem::transmute(binary_group_flag_bit2) };
            binary_group_flag_bit2 as u64
        });
        __bindgen_bitfield_unit.set(60usize, 4u8, {
            let user8: u32 = unsafe { ::std::mem::transmute(user8) };
            user8 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let sync_word: u32 = unsafe { ::std::mem::transmute(sync_word) };
            sync_word as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< 30fps"]
pub const LTC_TV_STANDARD_LTC_TV_525_60: LTC_TV_STANDARD = 0;
#[doc = "< 25fps"]
pub const LTC_TV_STANDARD_LTC_TV_625_50: LTC_TV_STANDARD = 1;
#[doc = "< 30fps"]
pub const LTC_TV_STANDARD_LTC_TV_1125_60: LTC_TV_STANDARD = 2;
#[doc = "< 24fps"]
pub const LTC_TV_STANDARD_LTC_TV_FILM_24: LTC_TV_STANDARD = 3;
#[doc = " the standard defines the assignment of the binary-group-flag bits"]
#[doc = " basically only 25fps is different, but other standards defined in"]
#[doc = " the SMPTE spec have been included for completeness."]
pub type LTC_TV_STANDARD = u32;
#[doc = "< LTCFrame <> SMPTETimecode converter and LTCFrame increment/decrement use date, also set BGF2 to '1' when encoder is initialized or re-initialized (unless LTC_BGF_DONT_TOUCH is given)"]
pub const LTC_BG_FLAGS_LTC_USE_DATE: LTC_BG_FLAGS = 1;
#[doc = "< the Timecode is wall-clock aka freerun. This also sets BGF1 (unless LTC_BGF_DONT_TOUCH is given)"]
pub const LTC_BG_FLAGS_LTC_TC_CLOCK: LTC_BG_FLAGS = 2;
#[doc = "< encoder init or re-init does not touch the BGF bits (initial values after initialization is zero)"]
pub const LTC_BG_FLAGS_LTC_BGF_DONT_TOUCH: LTC_BG_FLAGS = 4;
#[doc = "< parity bit is left untouched when setting or in/decrementing the encoder frame-number"]
pub const LTC_BG_FLAGS_LTC_NO_PARITY: LTC_BG_FLAGS = 8;
#[doc = " encoder and LTCframe <> timecode operation flags"]
pub type LTC_BG_FLAGS = u32;
#[doc = " Extended LTC frame - includes audio-sample position offsets, volume, etc"]
#[doc = ""]
#[doc = " Note: For TV systems, the sample in the LTC audio data stream where the LTC Frame starts is not necessarily at the same time"]
#[doc = " as the video-frame which is described by the LTC Frame."]
#[doc = ""]
#[doc = " \\ref off_start denotes the time of the first transition of bit 0 in the LTC frame."]
#[doc = ""]
#[doc = " For 525/60 Television systems, the first transition shall occur at the beginning of line 5 of the frame with which it is"]
#[doc = " associated. The tolerance is \u{b1} 1.5 lines."]
#[doc = ""]
#[doc = " For 625/50 systems, the first transition shall occur at the beginning of line 2  \u{b1} 1.5 lines of the frame with which it is associated."]
#[doc = ""]
#[doc = " Only for 1125/60 systems, the first transition occurs exactly at the vertical sync timing reference of the frame. \u{b1} 1 line."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LTCFrameExt {
    #[doc = "< the actual LTC frame. see \\ref LTCFrame"]
    pub ltc: LTCFrame,
    #[doc = "< \\anchor off_start the approximate sample in the stream corresponding to the start of the LTC frame."]
    pub off_start: ltc_off_t,
    #[doc = "< \\anchor off_end the sample in the stream corresponding to the end of the LTC frame."]
    pub off_end: ltc_off_t,
    #[doc = "< if non-zero, a reverse played LTC frame was detected. Since the frame was reversed, it started at off_end and finishes as off_start (off_end > off_start). (Note: in reverse playback the (reversed) sync-word of the next/previous frame is detected, this offset is corrected)."]
    pub reverse: ::std::os::raw::c_int,
    #[doc = "< detailed timing info: phase of the LTC signal; the time between each bit in the LTC-frame in audio-frames. Summing all 80 values in the array will yield audio-frames/LTC-frame = (\\ref off_end - \\ref off_start + 1)."]
    pub biphase_tics: [f32; 80usize],
    #[doc = "< the minimum input sample signal for this frame (0..255)"]
    pub sample_min: ltcsnd_sample_t,
    #[doc = "< the maximum input sample signal for this frame (0..255)"]
    pub sample_max: ltcsnd_sample_t,
    #[doc = "< the volume of the input signal in dbFS"]
    pub volume: f64,
}
#[test]
fn bindgen_test_layout_LTCFrameExt() {
    assert_eq!(
        ::std::mem::size_of::<LTCFrameExt>(),
        368usize,
        concat!("Size of: ", stringify!(LTCFrameExt))
    );
    assert_eq!(
        ::std::mem::align_of::<LTCFrameExt>(),
        8usize,
        concat!("Alignment of ", stringify!(LTCFrameExt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LTCFrameExt>())).ltc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LTCFrameExt),
            "::",
            stringify!(ltc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LTCFrameExt>())).off_start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LTCFrameExt),
            "::",
            stringify!(off_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LTCFrameExt>())).off_end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LTCFrameExt),
            "::",
            stringify!(off_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LTCFrameExt>())).reverse as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LTCFrameExt),
            "::",
            stringify!(reverse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LTCFrameExt>())).biphase_tics as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LTCFrameExt),
            "::",
            stringify!(biphase_tics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LTCFrameExt>())).sample_min as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(LTCFrameExt),
            "::",
            stringify!(sample_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LTCFrameExt>())).sample_max as *const _ as usize },
        357usize,
        concat!(
            "Offset of field: ",
            stringify!(LTCFrameExt),
            "::",
            stringify!(sample_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LTCFrameExt>())).volume as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(LTCFrameExt),
            "::",
            stringify!(volume)
        )
    );
}
impl Default for LTCFrameExt {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Human readable time representation, decimal values."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SMPTETimecode {
    #[doc = "< the timezone 6bytes: \"+HHMM\" textual representation"]
    pub timezone: [::std::os::raw::c_char; 6usize],
    #[doc = "< LTC-date uses 2-digit year 00.99"]
    pub years: ::std::os::raw::c_uchar,
    #[doc = "< valid months are 1..12"]
    pub months: ::std::os::raw::c_uchar,
    #[doc = "< day of month 1..31"]
    pub days: ::std::os::raw::c_uchar,
    #[doc = "< hour 0..23"]
    pub hours: ::std::os::raw::c_uchar,
    #[doc = "< minute 0..60"]
    pub mins: ::std::os::raw::c_uchar,
    #[doc = "< second 0..60"]
    pub secs: ::std::os::raw::c_uchar,
    #[doc = "< sub-second frame 0..(FPS - 1)"]
    pub frame: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_SMPTETimecode() {
    assert_eq!(
        ::std::mem::size_of::<SMPTETimecode>(),
        13usize,
        concat!("Size of: ", stringify!(SMPTETimecode))
    );
    assert_eq!(
        ::std::mem::align_of::<SMPTETimecode>(),
        1usize,
        concat!("Alignment of ", stringify!(SMPTETimecode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETimecode>())).timezone as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETimecode),
            "::",
            stringify!(timezone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETimecode>())).years as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETimecode),
            "::",
            stringify!(years)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETimecode>())).months as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETimecode),
            "::",
            stringify!(months)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETimecode>())).days as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETimecode),
            "::",
            stringify!(days)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETimecode>())).hours as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETimecode),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETimecode>())).mins as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETimecode),
            "::",
            stringify!(mins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETimecode>())).secs as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETimecode),
            "::",
            stringify!(secs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETimecode>())).frame as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETimecode),
            "::",
            stringify!(frame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LTCDecoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LTCEncoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Convert binary LTCFrame into SMPTETimecode struct"]
    #[doc = ""]
    #[doc = " @param stime output"]
    #[doc = " @param frame input"]
    #[doc = " @param flags binary combination of \\ref LTC_BG_FLAGS - here only LTC_USE_DATE is relevant."]
    #[doc = " if LTC_USE_DATE is set, the user-fields in LTCFrame will be parsed into the date variable of SMPTETimecode."]
    #[doc = " otherwise the date information in the SMPTETimecode is set to zero."]
    pub fn ltc_frame_to_time(
        stime: *mut SMPTETimecode,
        frame: *mut LTCFrame,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Translate SMPTETimecode struct into its binary LTC representation"]
    #[doc = " and set the LTC frame's parity bit accordingly (see \\ref ltc_frame_set_parity)"]
    #[doc = ""]
    #[doc = " @param frame output - the frame to be set"]
    #[doc = " @param stime input - timecode input"]
    #[doc = " @param standard the TV standard to use for parity bit assignment"]
    #[doc = " @param flags binary combination of \\ref LTC_BG_FLAGS - here only LTC_USE_DATE and LTC_NO_PARITY are relevant."]
    #[doc = " if LTC_USE_DATE is given, user-fields in LTCFrame will be set from the date in SMPTETimecode,"]
    #[doc = " otherwise the user-bits are not modified. All non-timecode fields remain untouched - except for the parity bit"]
    #[doc = " unless LTC_NO_PARITY is given."]
    pub fn ltc_time_to_frame(
        frame: *mut LTCFrame,
        stime: *mut SMPTETimecode,
        standard: LTC_TV_STANDARD,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Reset all values of a LTC FRAME to zero, except for the sync-word (0x3FFD) at the end."]
    #[doc = " The sync word is set according to architecture (big/little endian)."]
    #[doc = " Also set the Frame's parity bit accordingly (see \\ref ltc_frame_set_parity)"]
    #[doc = " @param frame the LTCFrame to reset"]
    pub fn ltc_frame_reset(frame: *mut LTCFrame);
}
extern "C" {
    #[doc = " Increment the timecode by one Frame (1/framerate seconds)"]
    #[doc = " and set the Frame's parity bit accordingly (see \\ref ltc_frame_set_parity)"]
    #[doc = ""]
    #[doc = " @param frame the LTC-timecode to increment"]
    #[doc = " @param fps integer framerate (for drop-frame-timecode set frame->dfbit and round-up the fps)."]
    #[doc = " @param standard the TV standard to use for parity bit assignment"]
    #[doc = " if set to 1 the 25fps standard is enabled and LTC Frame bit 59 instead of 27 is used for the parity. It only has only has effect flag bit 4 (LTC_NO_PARITY) is cleared."]
    #[doc = " @param flags binary combination of \\ref LTC_BG_FLAGS - here only LTC_USE_DATE and LTC_NO_PARITY are relevant."]
    #[doc = " If the bit 0 (1) is set (1) interpret user-data as date and increment date if timecode wraps after 24h."]
    #[doc = " (Note: leap-years are taken into account, but since the year is two-digit only, the 100,400yr rules are ignored."]
    #[doc = " \"00\" is assumed to be year 2000 which was a leap year.)"]
    #[doc = " @return 1 if timecode was wrapped around after 23:59:59:ff, 0 otherwise"]
    pub fn ltc_frame_increment(
        frame: *mut LTCFrame,
        fps: ::std::os::raw::c_int,
        standard: LTC_TV_STANDARD,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decrement the timecode by one Frame (1/framerate seconds)"]
    #[doc = " and set the Frame's parity bit accordingly (see \\ref ltc_frame_set_parity)"]
    #[doc = ""]
    #[doc = " @param frame the LTC-timecode to decrement"]
    #[doc = " @param fps integer framerate (for drop-frame-timecode set frame->dfbit and round-up the fps)."]
    #[doc = " @param standard the TV standard to use for parity bit assignment"]
    #[doc = " if set to 1 the 25fps standard is enabled and LTC Frame bit 59 instead of 27 is used for the parity. It only has only has effect flag bit 4 (LTC_NO_PARITY) is cleared."]
    #[doc = " @param flags binary combination of \\ref LTC_BG_FLAGS - here only LTC_USE_DATE and LTC_NO_PARITY are relevant."]
    #[doc = " if the bit 0 is set (1) interpret user-data as date and decrement date if timecode wraps at 24h."]
    #[doc = " (Note: leap-years are taken into account, but since the year is two-digit only, the 100,400yr rules are ignored."]
    #[doc = " \"00\" is assumed to be year 2000 which was a leap year.)"]
    #[doc = " bit 3 (8) indicates that the parity bit should not be touched"]
    #[doc = " @return 1 if timecode was wrapped around at 23:59:59:ff, 0 otherwise"]
    pub fn ltc_frame_decrement(
        frame: *mut LTCFrame,
        fps: ::std::os::raw::c_int,
        standard: LTC_TV_STANDARD,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new LTC decoder."]
    #[doc = ""]
    #[doc = " @param apv audio-frames per video frame. This is just used for initial settings, the speed is tracked dynamically. setting this in the right ballpark is needed to properly decode the first LTC frame in a sequence."]
    #[doc = " @param queue_size length of the internal queue to store decoded frames"]
    #[doc = " to SMPTEDecoderWrite."]
    #[doc = " @return decoder handle or NULL if out-of-memory"]
    pub fn ltc_decoder_create(
        apv: ::std::os::raw::c_int,
        queue_size: ::std::os::raw::c_int,
    ) -> *mut LTCDecoder;
}
extern "C" {
    #[doc = " Release memory of decoder."]
    #[doc = " @param d decoder handle"]
    pub fn ltc_decoder_free(d: *mut LTCDecoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Feed the LTC decoder with new audio samples."]
    #[doc = ""]
    #[doc = " Parse raw audio for LTC timestamps. Once a complete LTC frame has been"]
    #[doc = " decoded it is pushed into a queue (\\ref ltc_decoder_read)"]
    #[doc = ""]
    #[doc = " @param d decoder handle"]
    #[doc = " @param buf pointer to ltcsnd_sample_t - unsigned 8 bit mono audio data"]
    #[doc = " @param size \\anchor size number of samples to parse"]
    #[doc = " @param posinfo (optional, recommended) sample-offset in the audio-stream. It is added to \\ref off_start, \\ref off_end in \\ref LTCFrameExt and should be monotonic (ie incremented by \\ref size for every call to ltc_decoder_write)"]
    pub fn ltc_decoder_write(
        d: *mut LTCDecoder,
        buf: *mut ltcsnd_sample_t,
        size: usize,
        posinfo: ltc_off_t,
    );
}
extern "C" {
    #[doc = " Wrapper around \\ref ltc_decoder_write that accepts floating point"]
    #[doc = " audio samples. Note: internally libltc uses 8 bit only."]
    #[doc = ""]
    #[doc = " @param d decoder handle"]
    #[doc = " @param buf pointer to audio sample data"]
    #[doc = " @param size number of samples to parse"]
    #[doc = " @param posinfo (optional, recommended) sample-offset in the audio-stream."]
    pub fn ltc_decoder_write_float(
        d: *mut LTCDecoder,
        buf: *mut f32,
        size: usize,
        posinfo: ltc_off_t,
    );
}
extern "C" {
    #[doc = " Wrapper around \\ref ltc_decoder_write that accepts signed 16 bit"]
    #[doc = " audio samples. Note: internally libltc uses 8 bit only."]
    #[doc = ""]
    #[doc = " @param d decoder handle"]
    #[doc = " @param buf pointer to audio sample data"]
    #[doc = " @param size number of samples to parse"]
    #[doc = " @param posinfo (optional, recommended) sample-offset in the audio-stream."]
    pub fn ltc_decoder_write_s16(
        d: *mut LTCDecoder,
        buf: *mut ::std::os::raw::c_short,
        size: usize,
        posinfo: ltc_off_t,
    );
}
extern "C" {
    #[doc = " Wrapper around \\ref ltc_decoder_write that accepts unsigned 16 bit"]
    #[doc = " audio samples. Note: internally libltc uses 8 bit only."]
    #[doc = ""]
    #[doc = " @param d decoder handle"]
    #[doc = " @param buf pointer to audio sample data"]
    #[doc = " @param size number of samples to parse"]
    #[doc = " @param posinfo (optional, recommended) sample-offset in the audio-stream."]
    pub fn ltc_decoder_write_u16(
        d: *mut LTCDecoder,
        buf: *mut ::std::os::raw::c_ushort,
        size: usize,
        posinfo: ltc_off_t,
    );
}
extern "C" {
    #[doc = " Decoded LTC frames are placed in a queue. This function retrieves"]
    #[doc = " a frame from the queue, and stores it at LTCFrameExt*"]
    #[doc = ""]
    #[doc = " @param d decoder handle"]
    #[doc = " @param frame the decoded LTC frame is copied there"]
    #[doc = " @return 1 on success or 0 when no frames queued."]
    pub fn ltc_decoder_read(d: *mut LTCDecoder, frame: *mut LTCFrameExt) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all LTC frames from the internal queue."]
    #[doc = " @param d decoder handle"]
    pub fn ltc_decoder_queue_flush(d: *mut LTCDecoder);
}
extern "C" {
    #[doc = " Count number of LTC frames currently in the queue."]
    #[doc = " @param d decoder handle"]
    #[doc = " @return number of queued frames"]
    pub fn ltc_decoder_queue_length(d: *mut LTCDecoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and initialize LTC audio encoder."]
    #[doc = ""]
    #[doc = " calls \\ref ltc_encoder_reinit internally see, see notes there."]
    #[doc = ""]
    #[doc = " @param sample_rate audio sample rate (eg. 48000)"]
    #[doc = " @param fps video-frames per second (e.g. 25.0)"]
    #[doc = " @param standard the TV standard to use for Binary Group Flag bit position"]
    #[doc = " @param flags binary combination of \\ref LTC_BG_FLAGS"]
    pub fn ltc_encoder_create(
        sample_rate: f64,
        fps: f64,
        standard: LTC_TV_STANDARD,
        flags: ::std::os::raw::c_int,
    ) -> *mut LTCEncoder;
}
extern "C" {
    #[doc = " Release memory of the encoder."]
    #[doc = " @param e encoder handle"]
    pub fn ltc_encoder_free(e: *mut LTCEncoder);
}
extern "C" {
    #[doc = " Set the encoder LTC-frame to the given SMPTETimecode."]
    #[doc = " The next call to \\ref ltc_encoder_encode_byte or"]
    #[doc = " \\ref ltc_encoder_encode_frame will encode this time to LTC audio-samples."]
    #[doc = ""]
    #[doc = " Internally this call uses \\ref ltc_time_to_frame because"]
    #[doc = " the LTCEncoder operates on LTCframes only."]
    #[doc = " see als \\ref ltc_encoder_set_frame"]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param t timecode to set."]
    pub fn ltc_encoder_set_timecode(e: *mut LTCEncoder, t: *mut SMPTETimecode);
}
extern "C" {
    #[doc = " Query the current encoder timecode."]
    #[doc = ""]
    #[doc = " Note: the decoder stores its internal state in an LTC-frame,"]
    #[doc = " this function converts that LTC-Frame into SMPTETimecode on demand."]
    #[doc = " see also \\ref ltc_encoder_get_frame."]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param t is set to current timecode"]
    pub fn ltc_encoder_get_timecode(e: *mut LTCEncoder, t: *mut SMPTETimecode);
}
extern "C" {
    #[doc = " Set the user-bits of the frame to the given data."]
    #[doc = ""]
    #[doc = " The data should be a 32-bits unsigned integer."]
    #[doc = " It is written LSB first continiously int the eight user fields."]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param data the data to write"]
    pub fn ltc_encoder_set_user_bits(e: *mut LTCEncoder, data: ::std::os::raw::c_ulong);
}
extern "C" {
    #[doc = " Get a 32-bits unsigned integer from the user-data bits."]
    #[doc = " The data should be written LSB first in the frame"]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    pub fn ltc_frame_get_user_bits(f: *mut LTCFrame) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Move the encoder to the next timecode frame."]
    #[doc = " uses \\ref ltc_frame_increment() internally."]
    pub fn ltc_encoder_inc_timecode(e: *mut LTCEncoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move the encoder to the previous timecode frame."]
    #[doc = " This is useful for encoding reverse LTC."]
    #[doc = " uses \\ref ltc_frame_decrement() internally."]
    pub fn ltc_encoder_dec_timecode(e: *mut LTCEncoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Low-level access to the internal LTCFrame data."]
    #[doc = ""]
    #[doc = " Note: be careful to about f->dfbit, the encoder sets this [only] upon"]
    #[doc = " initialization."]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param f LTC frame data to use"]
    pub fn ltc_encoder_set_frame(e: *mut LTCEncoder, f: *mut LTCFrame);
}
extern "C" {
    #[doc = " Low-level access to the encoder internal LTCFrame data"]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param f return LTC frame data"]
    pub fn ltc_encoder_get_frame(e: *mut LTCEncoder, f: *mut LTCFrame);
}
extern "C" {
    #[doc = " Copy the accumulated encoded audio to the given"]
    #[doc = " sample-buffer and flush the internal buffer."]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param buf place to store the audio-samples, needs to be large enough"]
    #[doc = " to hold \\ref ltc_encoder_get_buffersize bytes"]
    #[doc = " @return the number of bytes written to the memory area"]
    #[doc = " pointed to by buf."]
    pub fn ltc_encoder_get_buffer(
        e: *mut LTCEncoder,
        buf: *mut ltcsnd_sample_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve a pointer to the accumulated encoded audio-data."]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param size if set, the number of valid bytes in the buffer is stored there"]
    #[doc = " @param flush call \\ref ltc_encoder_buffer_flush - reset the buffer write-pointer"]
    #[doc = " @return pointer to encoder-buffer"]
    pub fn ltc_encoder_get_bufptr(
        e: *mut LTCEncoder,
        size: *mut ::std::os::raw::c_int,
        flush: ::std::os::raw::c_int,
    ) -> *mut ltcsnd_sample_t;
}
extern "C" {
    #[doc = " reset the write-pointer of the encoder-buffer"]
    #[doc = " @param e encoder handle"]
    pub fn ltc_encoder_buffer_flush(e: *mut LTCEncoder);
}
extern "C" {
    #[doc = " Query the length of the internal buffer. It is allocated"]
    #[doc = " to hold audio-frames for exactly one LTC frame for the given"]
    #[doc = " sample-rate and frame-rate.  ie. (1 + sample-rate / fps) bytes"]
    #[doc = ""]
    #[doc = " Note this returns the total size of the buffer, not the used/free"]
    #[doc = " part. See also \\ref ltc_encoder_get_bufptr"]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @return size of the allocated internal buffer."]
    pub fn ltc_encoder_get_buffersize(e: *mut LTCEncoder) -> usize;
}
extern "C" {
    #[doc = " Change the encoder settings without re-allocating any"]
    #[doc = " library internal data structure (realtime safe)."]
    #[doc = " changing the fps and or sample-rate implies a buffer flush,"]
    #[doc = " and biphase state reset."]
    #[doc = ""]
    #[doc = " This call will fail if the internal buffer is too small"]
    #[doc = " to hold one full LTC frame. Use \\ref ltc_encoder_set_bufsize to"]
    #[doc = " prepare an internal buffer large enough to accommodate all"]
    #[doc = " sample_rate, fps combinations that you would like to re-init to."]
    #[doc = ""]
    #[doc = " The LTC frame payload data is not modified by this call, however,"]
    #[doc = " the flag-bits of the LTC-Frame are updated:"]
    #[doc = " If fps equals to 29.97 or 30000.0/1001.0, the LTCFrame's 'dfbit' bit is set to 1"]
    #[doc = " to indicate drop-frame timecode."]
    #[doc = ""]
    #[doc = " Unless the LTC_BGF_DONT_TOUCH flag is set the BGF1 is set or cleared depending"]
    #[doc = " on LTC_TC_CLOCK and BGF0,2 according to LTC_USE_DATE and the given standard."]
    #[doc = " col_frame is cleared  and the parity recomputed (unless LTC_NO_PARITY is given)."]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param sample_rate audio sample rate (eg. 48000)"]
    #[doc = " @param fps video-frames per second (e.g. 25.0)"]
    #[doc = " @param standard the TV standard to use for Binary Group Flag bit position"]
    #[doc = " @param flags binary combination of \\ref LTC_BG_FLAGS"]
    pub fn ltc_encoder_reinit(
        e: *mut LTCEncoder,
        sample_rate: f64,
        fps: f64,
        standard: LTC_TV_STANDARD,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " reset ecoder state."]
    #[doc = " flushes buffer, reset biphase state"]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    pub fn ltc_encoder_reset(e: *mut LTCEncoder);
}
extern "C" {
    #[doc = " Configure a custom size for the internal buffer."]
    #[doc = ""]
    #[doc = " This is needed if you are planning to call \\ref ltc_encoder_reinit()"]
    #[doc = " or if you want to keep more than one LTC frame's worth of data in"]
    #[doc = " the library's internal buffer."]
    #[doc = ""]
    #[doc = " The buffer-size is (1 + sample_rate / fps) bytes."]
    #[doc = " resizing the internal buffer will flush all existing data"]
    #[doc = " in it - alike \\ref ltc_encoder_buffer_flush."]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param sample_rate audio sample rate (eg. 48000)"]
    #[doc = " @param fps video-frames per second (e.g. 25.0)"]
    #[doc = " @return 0 on success, -1 if allocation fails (which makes the"]
    #[doc = "   encoder unusable, call \\ref ltc_encoder_free or realloc the buffer)"]
    pub fn ltc_encoder_set_bufsize(
        e: *mut LTCEncoder,
        sample_rate: f64,
        fps: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the volume of the generated LTC signal"]
    #[doc = ""]
    #[doc = " typically LTC is sent at 0dBu ; in EBU callibrated systems that"]
    #[doc = " corresponds to -18dBFS. - by default libltc creates -3dBFS"]
    #[doc = ""]
    #[doc = " since libltc generated 8bit audio-data, the minimum dBFS"]
    #[doc = " is about -42dB which corresponds to 1 bit."]
    #[doc = ""]
    #[doc = " 0dB corresponds to a signal range of 127"]
    #[doc = " 1..255 with 128 at the center."]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param dBFS the volume in dB full-scale (<= 0.0)"]
    #[doc = " @return 0 on success, -1 if the value was out of range"]
    pub fn ltc_encoder_set_volume(e: *mut LTCEncoder, dBFS: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set encoder signal rise-time / signal filtering"]
    #[doc = ""]
    #[doc = " LTC signal should have a rise time of 40us +/- 10 us."]
    #[doc = " by default the encoder honors this and low-pass filters"]
    #[doc = " the output depending on the sample-rate."]
    #[doc = ""]
    #[doc = " If you want a perfect square wave, set 'rise_time' to 0."]
    #[doc = ""]
    #[doc = " Note \\ref ltc_encoder_reinit resets the filter-time-constant to use"]
    #[doc = " the default 40us for the given sample-rate, overriding any value"]
    #[doc = " previously set with \\ref ltc_encoder_set_filter"]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param rise_time the signal rise-time in us (10^(-6) sec), set to 0 for perfect square wave, default 40.0"]
    pub fn ltc_encoder_set_filter(e: *mut LTCEncoder, rise_time: f64);
}
extern "C" {
    #[doc = " Generate LTC audio for given byte of the LTC-frame and"]
    #[doc = " place it into the internal buffer."]
    #[doc = ""]
    #[doc = " see \\ref ltc_encoder_get_buffer and  \\ref ltc_encoder_get_bufptr"]
    #[doc = ""]
    #[doc = " LTC has 10 bytes per frame: 0 <= bytecnt < 10"]
    #[doc = " use SMPTESetTime(..) to set the current frame before Encoding."]
    #[doc = " see tests/encoder.c for an example."]
    #[doc = ""]
    #[doc = " The default output signal is @ -3dBFS (38..218 at 8 bit unsigned)."]
    #[doc = " see also \\ref ltc_encoder_set_volume"]
    #[doc = ""]
    #[doc = " if speed is < 0, the bits are encoded in reverse."]
    #[doc = " slowdown > 10.0 requires custom buffer sizes; see \\ref ltc_encoder_set_bufsize"]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    #[doc = " @param byte byte of the LTC-frame to encode 0..9"]
    #[doc = " @param speed vari-speed, < 1.0 faster,  > 1.0 slower ; must be != 0"]
    #[doc = ""]
    #[doc = " @return 0 on success, -1 if byte is invalid or buffer overflow (speed > 10.0)"]
    pub fn ltc_encoder_encode_byte(
        e: *mut LTCEncoder,
        byte: ::std::os::raw::c_int,
        speed: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode a full LTC frame at fixed speed."]
    #[doc = " This is equivalent to calling \\ref ltc_encoder_encode_byte 10 times for"]
    #[doc = " bytes 0..9 with speed 1.0."]
    #[doc = ""]
    #[doc = " Note: The internal buffer must be empty before calling this function."]
    #[doc = " Otherwise it may overflow. This is usually the case if it is read with"]
    #[doc = " \\ref ltc_encoder_get_buffer after calling this function."]
    #[doc = ""]
    #[doc = " The default internal buffersize is exactly one full LTC frame at speed 1.0."]
    #[doc = ""]
    #[doc = " @param e encoder handle"]
    pub fn ltc_encoder_encode_frame(e: *mut LTCEncoder);
}
extern "C" {
    #[doc = " Set the parity of the LTC frame."]
    #[doc = ""]
    #[doc = " Bi-Phase Mark Phase Correction bit (bit 27 - or 59) may be set or cleared so that"]
    #[doc = " that every 80-bit word contains an even number of zeroes."]
    #[doc = " This means that the phase in every Sync Word will be the same."]
    #[doc = ""]
    #[doc = " This is merely cosmetic; the motivation to keep the polarity of the waveform"]
    #[doc = " constant is to make finding the Sync Word visibly (on a scope) easier."]
    #[doc = ""]
    #[doc = " There is usually no need to call this function directly. The encoder utility"]
    #[doc = " functions \\ref ltc_time_to_frame, \\ref ltc_frame_increment and"]
    #[doc = " \\ref ltc_frame_decrement include a call to it."]
    #[doc = ""]
    #[doc = " @param frame the LTC to analyze and set or clear the biphase_mark_phase_correction bit."]
    #[doc = " @param standard If 1 (aka LTC_TV_625_50) , the 25fps mode (bit 59 - aka binary_group_flag_bit2) is used, otherwise the 30fps, 24fps mode (bit 27 -- biphase_mark_phase_correction) is set or cleared."]
    pub fn ltc_frame_set_parity(frame: *mut LTCFrame, standard: LTC_TV_STANDARD);
}
extern "C" {
    #[doc = " Parse Binary Group Flags into standard independent format:"]
    #[doc = " bit 0 (1) - BGF 0,"]
    #[doc = " bit 1 (2) - BGF 1,"]
    #[doc = " bit 2 (4) - BGF 2"]
    #[doc = ""]
    #[doc = " @param f LTC frame data analyze"]
    #[doc = " @param standard the TV standard to use -- see \\ref LTCFrame for BGF assignment"]
    #[doc = " @return LTC Binary Group Flags"]
    pub fn parse_bcg_flags(f: *mut LTCFrame, standard: LTC_TV_STANDARD) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LTCFrame sample alignment offset."]
    #[doc = ""]
    #[doc = " There is a relative offset of the LTC-Frame start and the TV-frame."]
    #[doc = " The first bit of a LTC frame corresponds to a specific line in the actual video"]
    #[doc = " frame. When decoding this offset needs to be subtracted from the LTC-frame's"]
    #[doc = " audio-sample-time to match the TV-frame's start position."]
    #[doc = ""]
    #[doc = " For film frames or HDV the offset is zero."]
    #[doc = ""]
    #[doc = " @param samples_per_frame audio-samples per timecode-frame (eg. 1920 = 48000/25)"]
    #[doc = " @param standard the TV standard"]
    #[doc = " @return offset in samples"]
    pub fn ltc_frame_alignment(samples_per_frame: f64, standard: LTC_TV_STANDARD) -> ltc_off_t;
}
